# Einleitung
## Ziel und Aufgabestellung
Ziel dieses Praktikums war es, eine exemplarische Elixir-Anwendung auf einem Kubernetes-Cluster in Betrieb zu setzen und anhand des aufgebauten Setups das Zusammenspiel der beiden Softwaresysteme zu untersuchen und zu diskutieren. Dabei sollten besonders Überschneidungen der beiden genannten Softwaresysteme im Zentrum der Evaluation stehen, sobald diese in Kombination betrieben werden.

## Elixir
[Elixir](https://elixir-lang.org/) ist eine funktionale Programmiersprache, welche die Erlang Virtual Machine verwendet. Alle Funktionen des Erlang Ökosystems können dabei in Elixir genutzt werden. Elixir wurde von Beginn an für hohe Parallelität ausgelegt, wobei das Konzept der Arbeitsverteilung über separate Prozesse bereits in die Semantik der Sprache eingebettet ist. Prozesse in Elixir sind schnelle und leichtgewichtige Parallelitätseinheiten, von denen Millionen auf einer einzigen Maschine erzeugt werden können. Diese Prozesse sind also von Betriebssystemprozessen entkoppelt, teilen keinen gemeinsamen Speicher ("immutability") und werden vollständig von der Erlang-VM verwaltet. Statt über gemeinsamen Speicher können die Prozesse untereinander über Nachrichten kommunizieren, wobei alle Prozesse eine Mailbox enthalten, in welcher empfangene Nachrichten passiv aufbewahrt werden, bis sie abgerufen wurden. Diese Art der Prozess-Kommunikation funktioniert auch zwischen Prozessen, die auf verschiedenen Rechnern im selben Netz laufen. Die beiden vorher genannten Konzepte werden auch als "Actor Model" und "Message Passing Pattern" bezeichnet. Unter Nutzung dieser Ansätze und des Supervisor-Konzeptes können Elixir-Anwendungen sehr fehlertolerant aufgebaut werden. Elixir eignet sich also sehr gut für Echtzeitanwendungen, wo Parallelität, geringe Latenz und gute Skalierbarkeit eine große Rolle spielt. Beispiele für solche Anwendungen sind Chat-Systemen oder Streaming-Backends. Es kommt dabei im Produktiveinsatz nicht selten vor, dass ein einzelner Rechner via Elixir Millionen von Netzwerkverbindungen parallel verarbeitet.

Um im Rahmen unseres Projektes die ToDo-Anwendung aufzubauen, nutzen wir zusätzlich das [Phoenix Framework](https://www.phoenixframework.org/), welches komplett in Elixir implementiert wurde. Phoenix ist ein Web-Entwicklungs-Framework, dass serverseitig ein Model View Controller (MVC) implementiert und dabei alle nötigen Funktionalitäten zur Verfügung stellt, um hoch reaktive Echtzeitanwendungen aufzubauen. Das Framework bietet standardmäßig die Möglichkeit an, für die Kommunikation zwischen Client und Server eine bidirektionale Verbindung über das effiziente [WebSocket-Protokoll](https://datatracker.ietf.org/doc/html/rfc6455) zu nutzen. Serverseitig steht für das asynchrone Nachrichtenhandling ein PubSub-Kanal zur Verfügung, welcher das Publish–subscribe Pattern implementiert. Weitere PubSub-Kanäle können via Kommandozeile über Generatoren erzeugt werden. Über diese integrierten Generatoren können fertige Programmierrahmen erzeugt werden, welche Standardentwicklungsschritte automatisieren. Dieses Konzept wird auch als Metaprogrammierung bezeichnet und stammt aus dem Gebiet der komponentenbasierten Entwicklung.

## Docker
Die entwickelte Elixir-Anwendung wird in unserem Projekt mittels Docker containerisiert. Die genutzte Postgres Datenbank wird auch innerhalb eines Containers bereitgestellt. Dieses Verfahren gewährt die Portierbarkeit der Anwendung – sie wird sich auf jedem System mit Docker gleich verhalten. Docker Container enthalten im Gegensatz zu virtuellen Maschinen meist eine abgespeckte Linux Distribution (z. B. Alpine Linux) und nutzen den Kernel des Host-Systems. Dies macht Docker Container leichtgewichtiger und schneller als komplette virtuelle Maschinen (z. B. QEMU oder Xen), bei welchen die komplette Hardware (para-)virtualisiert wird. Ein weiterer Vorteil von Containern ist, dass ihr Inhalt gegenüber anderen Containern isoliert ist. Versionskonflikte bei Software-Abhängigkeiten können so vermieden werden.

## Kubernetes
Kubernetes ist für die Ausführung und Orchestrierung der erstellten Container zuständig. Die Ausführung der Container erfolgt innerhalb von Pods, ein Pod kann auch mehrere Container enthalten. Die einzelnen Pods werden auf Kubernetes Nodes ausgeführt, mehrere dieser Nodes können zusammen ein Kubernetes Cluster formen. Kubernetes ermöglicht durch die Clustering-Funktionalitäten die vertikale Skalierung von Anwendungen, indem mehr Hardware in Form von Kubernetes Nodes zu einem Cluster hinzugefügt wird. Es kann weiterhin die Hochverfügbarkeit gewährleisten, wenn Cluster und Anwendung entsprechend konfiguriert sind, ansonsten findet nur ein Failover statt, bei welchem die Workload in Form von Pods beim Ausfall eines Nodes auf einen anderen Knoten des Clusters migriert wird.