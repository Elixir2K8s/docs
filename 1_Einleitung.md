# Einleitung
## Ziel und Aufgabestellung
Ziel dieses Praktikums war es, eine exemplarische Elixir-Anwendung auf einem Kubernetes-Cluster in Betrieb zu setzen und anhand des aufgebauten Setups das Zusammenspiel der beiden Softwaresysteme zu untersuchen und zu diskutieren. Im Mittelpunkt der Diskussion sollten dabei Überschneidungen der beiden genannten Softwaresysteme stehen, sobald diese in Kombination betrieben werden.

## Elixir
[Elixir](https://elixir-lang.org/) ist eine funktionale Programmiersprache, welche die Erlang Virtual Machine verwendet. Alle Funktionen des Erlang Ökosystems können dabei in Elixir genutzt werden. Elixir wurde von Beginn an für hohe Parallelität ausgelegt. Prozesse in Elixir sind schnelle und leichtgewichtige Parallelitätseinheiten, von denen Millionen auf einer einzigen Maschine erzeugt werden können. Diese Prozesse sind also von Betriebssystemprozessen entkoppelt, teilen keinen gemeinsamen Speicher ("immutability") und werden vollständig von der Erlang-VM verwaltet. Statt über gemeinsamen Speicher können die Prozesse untereinander über Nachrichten kommunizieren, wobei alle Prozesse eine Mailbox enthalten, in welcher empfangene Nachrichten passiv aufbewahrt werden, bis sie abgerufen wurden. Diese Art der Prozess-Kommunikation funktioniert auch zwischen Prozessen, die auf verschiedenen Rechnern im selben Netz laufen. Die beiden vorher genannten Konzepte werden auch als "Actor Model" und "Message Passing Pattern" bezeichnet. Unter Nutzung dieser Ansätze und des Supervisor-Konzeptes können Elixir-Anwendungen sehr fehlertolerant aufgebaut werden. Elixir eignet sich also sehr gut für Anwendungen, wo Parallelität, geringe Latenz und gute Skalierbarkeit eine große Rolle spielt, beispielsweise in Chat-Systemen oder Streaming-Backends. Es kommt dabei im Produktiveinsatz nicht selten vor, dass ein einzelner Rechner via Elixir Millionen von Netzwerkverbindungen parallel verarbeitet.

Um im Rahmen unseres Projektes die Todo-Listenverwaltungs-Anwendung aufzubauen, nutzen wir zusätzlich das [Phoenix Framework](https://www.phoenixframework.org/), welches komplett in Elixir implementiert wurde. Phoenix ist ein Web-Entwicklungs-Framework, dass serverseitig ein Model View Controller (MVC) implementiert und dabei alle nötigen Funktionalitäten zur Verfügung stellt, um hoch reaktive Echtzeitanwendungen aufzubauen. Das Framework bietet standardmäßig die Möglichkeit an, für die Kommunikation zwischen Client und Server eine bidirektionale Verbindung über das effiziente [WebSocket-Protokoll](https://datatracker.ietf.org/doc/html/rfc6455) zu nutzen. Serverseitig steht für das bidirektionale Nachrichtenhandling ein PubSub-Kanal zur Verfügung, welcher das Publish–subscribe Pattern implementiert. Weitere PubSub-Kanäle können via Kommandozeile über Generatoren erzeugt werden. Über diese integrierten Generatoren können fertige Programmierrahmen erzeugt werden, welche Standardentwicklungsschritte automatisieren.

## Docker
Die Anwendung wird in unserem Projekt mit Hilfe von Docker in Container verpackt. Solches Verfahren gewährt die Portierbarkeit der Anwendung – sie wird sich auf jedem System mit laufendem Docker gleich verhalten. Die Container, im Gegensatz zu Virtuelle Maschinen, enthalten kein Betriebssystem, also werden sie schneller erschafft und gestartet. Ein anderer großer Vorteil von einem Container ist, dass er völlig isoliert ist, also sind sie von den anderen Container unabhängig. Das heißt, wenn es zu einer Situation kommt, wo zwei verschiedene Container eine andere Version von der gleichen Software verwenden, gibt es keine Konflikte, sondern werden beide Versionen in entsprechenden Container verwendet. Mit Hilfe von Docker-Compose wird die Anwendung definiert und gestartet.
## Kubernetes
Kubernetes ist ein System die auf von Docker erstellte Container greift und die Orchestrierung bzw. die Automatisierung von Prozessen übernimmt. Pods sind die kleinsten logischen Einheiten in Kubernetes, die die Container enthalten (normalerweise ein Container pro Pod). Die Pods sind ein Teil von Arbeiterknoten, die zusammen mit anderen Knoten einen Cluster formen. Kubernetes ermöglicht die Skalierung der Anwendung, sodass die verfügbare Ressourcen optimal verwaltet werden. Es gewährleistet die Hochverfügbarkeit, das heißt, beim Ausfall eines Pods wird es mit entsprechendem Container automatisch neugestartet. In unserem Projekt verwenden wir Microk8s.
